## 泛型

JDK中判断方法是否重复：方法名、参数、返回值来判断在字节码是否重复。但编译IDE工具中只会判断参数和方法名。

泛型编译成字节码会做泛型擦除，Java虚拟机中在字节码用Signature（弱记忆）签名字段这里保留相关的泛型信息。



## 注解、反射

![image-20241106111626868](.asserts/image-20241106111626868.png)



## 进程、线程

1.6G cpu执行一条指令耗时0.6ns

一次线程切换的上下文切换占用约2000个CPU周期

不要用stop结束线程，可能资源未正常释放，一般用Interrupt

就绪不代表运行，需要等CPU时间片。

<img src=".asserts/image-20241106163113351.png" alt="image-20241106163113351" style="zoom:50%;" />

yield: 线程让出CPU（不会让出锁），操作系统再去选线程

join: 挂起当前运行的线程，给join的线程

setDaemon: 设置成守护线程，守护线程finally不一定会调用。



ThreadLocal引发的内存泄漏：

<img src=".asserts/image-20241107172445896.png" alt="image-20241107172445896" style="zoom:50%;" />

![image-20241107142431377](.asserts/image-20241107142431377.png)

<img src=".asserts/image-20241107170435064.png" alt="image-20241107170435064" style="zoom:50%;" />

只有synchronized能让线程进入阻塞态，lock和sleep都是等待/等待超时



Java实现中，有一个静态内部类ThreadLocalMap，内部定义了一个Entry是一个弱引用。会导致key被回收，但线程还持有value，导致没回收。可以用完后主动调用remove ，这里会调用ThreadLocal的expungeStaleEntry来清除key为null的。而set/get方法清除的不及时。



死锁：互斥、请求和保持、不剥夺/抢占、环路等待

#### 线程协作

Synchorized(xxx.this) {

​	while(!condintion) {

​		对象.wait();	// 对象wait后会马上释放锁

​	}

}

Synchorized(xxx.this) {

​	对象.notify()/.notifyAll();// 不会马上释放锁，要等后面Synchorized内代码块执行完。notify会随机唤醒同一个Synchorized对象的一个

​	业务逻辑；

}

yield(),sleep()不释放锁。



CAS问题：1.  ABA问题,如果变量被改了之后又被改回来；解决方案：AtomicMarkableReference或AtomicStampedReference。 2. 开销问题（自旋）。3.只能保证一个变量的原子操作；解决方案：AtomicReference。

<img src=".asserts/image-20241108092409337.png" alt="image-20241108092409337" style="zoom:50%;" />



#### 线程池

CPU密集型，最大线程数一般设置为：cpu核心数Runtime.getRuntime().availableProcessor() + 1;

IO密集型，最大线程数一般设置为：cpu核心数 * 2；

混合型，拆分线程池；

<img src=".asserts/image-20241107193109091.png" alt="image-20241107193109091" style="zoom:50%;" />



#### AQS

模版方法模式，实现类继承自AbstractQueuedSynchronizer，重写实现tryAcquire和tryRelease等，里面可以用CAS判断设置状态成功后调用AQS的setExclusiveOwnerThread来设置独占。

关键成员变量：state，保存同步状态



#### CLH队列锁

要排队的线程打包成QNode对象。队列中每个节点不断 用CAS去检查myPred前一个节点是否释放锁。

![image-20241108143822724](.asserts/image-20241108143822724.png)

公平锁和非公平锁实现区别：（公平锁tryAcquire要判断后去排队）

![image-20241108145106906](.asserts/image-20241108145106906.png)

可重入锁则在tryAcquire的时候判断拿锁的是不是自己线程，如果是要改state状态。



#### Synchnorized

JVM虚拟机帮忙插入montiorenter和montiorexit。但如果是加在方法上，则通过加ACC_SYNCHNORIZED实现。

Java对象头内容记录会变：

![image-20241108154358176](.asserts/image-20241108154358176.png)

轻量级锁：自旋尝试拿锁；

虚拟机动态判断自旋时间，超过限制（一般是一次上下文切换的时间）后升级锁；

虚拟机统计大部分情况下一个锁总是由同一个线程获取到，推出偏向锁；

偏向锁：检查上一个拿锁的线程是否自己线程（线程ID判断），如果是直接拿到锁；

锁升级：偏向锁（发现有其他线程，撤销偏向锁，撤销时会STW Stop The World）->轻量级锁 -> 重量级锁

高并发任务需要禁用偏向锁。

另外还有锁粗化、锁消除、逃逸分析；



## IO





## JVM&& JMM

<img src=".asserts/image-20241108185835177.png" alt="image-20241108185835177" style="zoom:50%;" />



## 
