#### 操作系统64位和32位有什么区别？

- 64位操作系统意味着其cpu拥有更大的寻址能力。理论上来说，其性能相比于32位操作系统会提升1倍。但是这也需要在64位操作系统上运行的软件也是64位的。
- 软件中数据类型的的字节数大小其实和操作系统是多少位的没有关系，而是由编译器决定的。也就是说数据结构占多少位取决于在软件编译时我们选择的是64位还是32位的编译器。其具体占位数在编译器已经决定了。

#### 数据类型对应字节数

- 下面是不同位数编译器下基本数据类型对应的字节数。

32位编译器：

```
char ：1个字节
char*（即指针变量）: 4个字节
short int : 2个字节
int：  4个字节
unsigned int : 4个字节
float:  4个字节
double:   8个字节
long:   4个字节
long long:  8个字节
unsigned long:  4个字节
```

64位编译器：

```
char ：1个字节
char*(即指针变量): 8个字节
short int : 2个字节
int：  4个字节
unsigned int : 4个字节
float:  4个字节
double:   8个字节
long:   8个字节
long long:  8个字节
unsigned long:  8个字节
```

- 总结：32位和64位编译器的基本数据类型字节数主要差别在64位的指针和long为8字节。



#### C++内存对齐

- 众所周知，为了保证每个对象拥有彼此独立的内存地址，C++空类的内存大小为1字节。而非空类的大小与类中非静态成员变量和虚函数表的多少有关。其中，类中非静态成员变量的大小则与编译器的位数以及内存对齐的设置有关。

- 类中的成员变量在内存中并不一定是连续的。它是按照编译器的设置，按照内存块来存储的，这个内存块大小的取值，就是内存对齐。

- 内存对齐有2个规则：

- - 第一个成员变量放在类中内存offset为0的地方，之后的成员变量的对齐按照#pragma pack(n)指定的数值和这个成员变量类型所占字节数中，比较小的那个进行（成员变量间补齐）。
  - 在成员变量完成各自内存对齐之后，类(结构或联合)本身也要进行内存对齐，对齐按照#pragma pack(n)指定的数值和类中最大成员变量类型所占字节数中，比较小的那个进行（类中最后一个成员变量结尾后补齐），类大小需要是对齐值得整数倍。

- \#pragma pack(n)作为一个预编译指令用来设置内存对齐的字节数。需要注意的是，n的缺省数值是编译器设置的，一般为8，合法的数值分别是1、2、4、8、16。



#### 延伸知识：C++空类大小

- C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。这是由于：

- - new需要分配不同的内存地址，不能分配内存大小为0的空间
  - 避免除以sizeof(T)时得到除以0错误故使用一个字节来区分空类。

- 需要注意的是，这并不代表一个空基类也需要加一个字节到子类中去。这种情况下，空基类并不是独立的，它附属于子类。子类继承空基类后，子类如果有自己的数据成员，则空基类的那一个字节并不会加到子类中去。

> *原文链接:* *https://juejin.cn/post/6916122498505539591*