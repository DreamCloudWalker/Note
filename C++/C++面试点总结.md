## 带虚函数空类的大小

**1. 空类**

```cpp
class A
{
};

void main()
{
    printf("sizeof(A): %d\\n", sizeof(A));
    getchar();
}
```

得到结果为：1。

类的实例化就是给每个实例在内存中分配一块地址。空类被实例化时，会由编译器隐含的添加一个字节。所以空类的size为1。

**2.虚函数**

```cpp
class A
{
    virtual void FuncA();    virtual void FuncB(); 
};
```

得到结果：4

当C++ 类中有虚函数的时候，会有一个指向虚函数表的指针（vptr），在32位系统分配指针大小为4字节。所以size为4.

**3.静态数据成员**

```cpp
class A
{
  int a;
  static int b;
  virtual void FuncA();
};
```

得到结果：8

**静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员．但是它不影响类的大小**，不管这个类实际产生了多少实例，还是派生了多少新的类，静态成员数据在类中永远只有一个实体存在。

**而类的非静态数据成员只有被实例化的时候，他们才存在．但是类的静态数据成员一旦被声明，无论类是否被实例化，它都已存在．可以这么说，类的静态数据成员是一种特殊的全局变量．**

所以该类的size为：int a型4字节加上虚函数表指针4字节，等于8字节。

**4.普通成员函数**

```cpp
class A
{
          void FuncA();
}
```

结果：1

**类的大小与它的构造函数、析构函数和其他成员函数无关，只已它的数据成员有关。**

**5.普通继承**

```cpp
class A
{
    int a;
};
class B
{
  int b;
};
class C : public A, public B
{
  int c;
};
```

结果为：sizeof(C) =12.

**可见普通的继承，就是基类的大小，加上派生类自身成员的大小。**

**6.虚拟继承**

```cpp
class C : virtual public A, virtual public B
{
  int c;
};
```

结果：16.

**当存在虚拟继承时，派生类中会有一个指向虚基类表的指针**。所以其大小应为普通继承的大小（12字节），再加上虚基类表的指针大小（4个字节），共16字节。