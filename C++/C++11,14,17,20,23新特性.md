# C++11新特性

## auto & decltype

关于C++11新特性，最先提到的肯定是类型推导，C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。

- auto：让编译器在编译器就推导出变量的类型，可以通过=右边的类型推导出变量的类型。

```c++
auto a = 10; // 10是int型，可以自动推导出a是int
```

- decltype：相对于auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。

```c++
cont int &i = 1;int a = 2;decltype(i) b = 2; // b是const int&
```

关于auto和decltype的详细介绍请看：[一文吃透C++11中auto和decltype知识点](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483911&idx=1&sn=9808fea93560af81c594e7d7c0f81ed9&chksm=eb7a0494dc0d8d82abfc0db427d921c93eb077e9f9162088b13651e81618bb231cb6f22f96a2&scene=21#wechat_redirect)



## 左值右值

众所周知C++11新增了右值引用，这里涉及到很多概念：

- 左值：可以取地址并且有名字的东西就是左值。
- 右值：不能取地址的没有名字的东西就是右值。
- 纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。
- 将亡值：可以理解为即将要销毁的值。
- 左值引用：对左值进行引用的类型。
- 右值引用：对右值进行引用的类型。
- 移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。
- 完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。
- 返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。

**概念1**：

左值：可以放到等号左边的东西叫左值。

右值：不可以放到等号左边的东西就叫右值。

**概念2**：

左值：可以取地址并且有名字的东西就是左值。

右值：不能取地址的没有名字的东西就是右值。

**举例**：

```c++
int a = b + c; 
```

a是左值，有变量名，可以取地址，也可以放到等号左边, 表达式b+c的返回值是右值，没有名字且不能取地址，&(b+c)不能通过编译，而且也不能放到等号左边。

```c++
int a = 4; // a是左值，4作为普通字面量是右值
```

左值一般有：

- 函数名和变量名

- 返回左值引用的函数调用

- 前置自增自减表达式++i、--i

- 由赋值表达式或赋值运算符连接的表达式(a=b, a += b等)

- 解引用表达式*p

- 字符串字面值"abcd"

  

## 纯右值、将亡值

纯右值和将亡值都属于右值。

#### 纯右值

运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。

**举例：**

- 除字符串字面值外的字面值
- 返回非引用类型的函数调用
- 后置自增自减表达式i++、i--
- 算术表达式(a+b, a*b, a&&b, a==b等)
- 取地址表达式等(&a)

#### 将亡值

将亡值是指C++11新增的和右值引用相关的表达式，通常指将要被移动的对象、T&&函数的返回值、std::move函数的返回值、转换为T&&类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。

**举例：**

```c++
class A {
    xxx;
};
A a;
auto c = std::move(a); // c是将亡值
auto d = static_cast<A&&>(a); // d是将亡值
```

**左值引用、右值引用**

根据名字大概就可以猜到意思，左值引用就是对左值进行引用的类型，右值引用就是对右值进行引用的类型，他们都是引用，都是对象的一个别名，并不拥有所绑定对象的堆存，所以都必须立即初始化。

```c++
type &name = exp; // 左值引用
type &&name = exp; // 右值引用
```

**左值引用**

看代码：

```c++
int a = 5;
int &b = a; // b是左值引用
b = 4;
int &c = 10; // error，10无法取地址，无法进行引用
const int &d = 10; // ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址
```

可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用const引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。

**右值引用**

如果使用右值引用，那表达式等号右边的值需要时右值，可以使用std::move函数强制把左值转换为右值。

```c++
int a = 4;
int &&b = a; // error, a是左值
int &&c = std::move(a); // ok
```



## **移动语义**

谈移动语义前，我们首先需要了解深拷贝与浅拷贝的概念

#### **深拷贝、浅拷贝**

直接拿代码举例:

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = a.data_;
        cout << "copy " << endl;
    }
    ~A() {
        delete[] data_;
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    cout << "b " << b.data_ << endl;
    cout << "a " << a.data_ << endl;
    return 0;
}
```

上面代码中，两个输出的是相同的地址，a和b的data_指针指向了同一块内存，这就是浅拷贝，只是数据的简单赋值，那再析构时data_内存会被释放两次，导致程序出问题，这里正常会出现double free导致程序崩溃的，但是不知道为什么我自己测试程序却没有崩溃，能力有限，没搞明白，无论怎样，这样的程序肯定是有隐患的，如何消除这种隐患呢，可以使用如下深拷贝：

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = new int[size_];
        cout << "copy " << endl;
    }
    ~A() {
        delete[] data_;
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    cout << "b " << b.data_ << endl;
    cout << "a " << a.data_ << endl;
    return 0;
}
```

深拷贝就是再拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值。

聊完了深拷贝浅拷贝，可以聊聊**移动语义**啦：

移动语义，在程序喵看来可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过移动构造函数。

```c++
class A {
public:
    A(int size) : size_(size) {
        data_ = new int[size];
    }
    A(){}
    A(const A& a) {
        size_ = a.size_;
        data_ = new int[size_];
        cout << "copy " << endl;
    }
    A(A&& a) {
        this->data_ = a.data_;
        a.data_ = nullptr;
        cout << "move " << endl;
    }
    ~A() {
        if (data_ != nullptr) {
         delete[] data_;
        }
    }
    int *data_;
    int size_;
};
int main() {
    A a(10);
    A b = a;
    A c = std::move(a); // 调用移动构造函数
    return 0;
}
```

如果不使用std::move()，会有很大的拷贝代价，使用移动语义可以避免很多无用的拷贝，提供程序性能，C++所有的STL都实现了移动语义，方便我们使用。例如：

```c++
std::vector<string> vecs;
...
std::vector<string> vecm = std::move(vecs); // 免去很多拷贝
```

**注意：**移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。



## 完美转发

完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用std::forward()。

```c++
void PrintV(int &t) {
    cout << "lvalue" << endl;
}

void PrintV(int &&t) {
    cout << "rvalue" << endl;
}

template<typename T>
void Test(T &&t) {
    PrintV(t);
    PrintV(std::forward<T>(t));

    PrintV(std::move(t));
}

int main() {
    Test(1); // lvalue rvalue rvalue
    int a = 1;
    Test(a); // lvalue lvalue rvalue
    Test(std::forward<int>(a)); // lvalue rvalue rvalue
    Test(std::forward<int&>(a)); // lvalue lvalue rvalue
    Test(std::forward<int&&>(a)); // lvalue rvalue rvalue
    return 0;
}
```

**分析**

- Test(1)：1是右值，模板中T &&t这种为万能引用，右值1传到Test函数中变成了右值引用，但是调用PrintV()时候，t变成了左值，因为它变成了一个拥有名字的变量，所以打印lvalue，而PrintV(std::forward<T>(t))时候，会进行完美转发，按照原来的类型转发，所以打印rvalue，PrintV(std::move(t))毫无疑问会打印rvalue。
- Test(a)：a是左值，模板中T &&这种为万能引用，左值a传到Test函数中变成了左值引用，所以有代码中打印。
- Test(std::forward<T>(a))：转发为左值还是右值，依赖于T，T是左值那就转发为左值，T是右值那就转发为右值。



## 返回值优化

返回值优化(RVO)是一种C++编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。

那什么时候编译器会进行返回值优化呢?

- return的值类型与函数的返回值类型相同
- return的是一个局部对象

看几个例子:

**示例1：**

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return tmp;
}
std::vector<int> &&rval_ref = return_vector();
```

不会触发RVO，拷贝构造了一个临时的对象，临时对象的生命周期和rval_ref绑定，等价于下面这段代码：

```c++
const std::vector<int>& rval_ref = return_vector();
```

**示例2：**

```c++
std::vector<int>&& return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return std::move(tmp);
}

std::vector<int> &&rval_ref = return_vector();
```

这段代码会造成运行时错误，因为rval_ref引用了被析构的tmp。讲道理来说这段代码是错的，但我自己运行过程中却成功了，我没有那么幸运，这里不纠结，继续向下看什么时候会触发RVO。

**示例3：**

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return std::move(tmp);
}

std::vector<int> &&rval_ref = return_vector();
```

和示例1类似，std::move一个临时对象是没有必要的，也会忽略掉返回值优化。

**最好的代码：**

```c++
std::vector<int> return_vector(void) {
    std::vector<int> tmp {1,2,3,4,5};
    return tmp;
}

std::vector<int> rval_ref = return_vector();
```

这段代码会触发RVO，不拷贝也不移动，不生成临时对象。



## 列表初始化

在C++11中可以直接在变量名后面加上初始化列表来进行对象的初始化，详细介绍:

```c++

struct A {
public:
   A(int) {}
private:
    A(const A&) {}
};
int main() {
   A a(123);
   A b = 123; // error
   A c = { 123 };
   A d{123}; // c++11
   
   int e = {123};
   int f{123}; // c++11
   
   return 0;
}
```

列表初始化也可以用在函数的返回值上

```C++
std::vector<int> func() {
   return {};
}
```

**列表初始化的一些规则**：

首先说下聚合类型可以进行直接列表初始化，这里需要了解什么是聚合类型：

1. 类型是一个普通数组，如int[5]，char[]，double[]等

2. 类型是一个类，且满足以下条件：

3. - 没有用户声明的构造函数
   - 没有用户提供的构造函数(允许显示预置或弃置的构造函数)
   - 没有私有或保护的非静态数据成员
   - 没有基类
   - 没有虚函数
   - 没有{}和=直接初始化的非静态数据成员
   - 没有默认成员初始化器

```c++
struct A {
   int a;
   int b;
   int c;
   A(int, int){}
};
int main() {
   A a{1, 2, 3};// error，A有自定义的构造函数，不能列表初始化
}
```

上述代码类A不是聚合类型，无法进行列表初始化，必须以自定义的构造函数来构造对象。

```c++
struct A {
int a;
   int b;
   virtual void func() {} // 含有虚函数，不是聚合类
};

struct Base {};
struct B : public Base { // 有基类，不是聚合类
int a;
   int b;
};

struct C {
   int a;
   int b = 10; // 有等号初始化，不是聚合类
};

struct D {
   int a;
   int b;
private:
   int c; // 含有私有的非静态数据成员，不是聚合类
};

struct E {
int a;
   int b;
   E() : a(0), b(0) {} // 含有默认成员初始化器，不是聚合类
};
```

上面列举了一些不是聚合类的例子，对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值；对于非聚合类型，需要先自定义一个对应的构造函数，此时列表初始化将调用相应的构造函数。

**std::initializer_list**

我们平时开发使用STL过程中可能发现它的初始化列表可以是任意长度，大家有没有想过它是怎么实现的呢，答案是std::initializer_list，看下面这段示例代码：

```c++
struct CustomVec {
   std::vector<int> data;
   CustomVec(std::initializer_list<int> list) {
       for (auto iter = list.begin(); iter != list.end(); ++iter) {
           data.push_back(*iter);
      }
  }
};
```

我想通过上面这段代码大家可能已经知道STL是如何实现的任意长度初始化了吧，这个std::initializer_list其实也可以作为函数参数。

注意：std::initializer_list<T>，它可以接收任意长度的初始化列表，但是里面必须是相同类型T，或者都可以转换为T。

**列表初始化的好处**

个人认为列表初始化的好处如下：

1. 方便，且基本上可以替代括号初始化
2. 可以使用初始化列表接受任意长度
3. 可以防止类型窄化，避免精度丢失的隐式类型转换

什么是类型窄化，列表初始化通过禁止下列转换，对隐式转化加以限制：

- 从浮点类型到整数类型的转换
- 从 long double 到 double 或 float 的转换，以及从 double 到 float 的转换，除非源是常量表达式且不发生溢出
- 从整数类型到浮点类型的转换，除非源是其值能完全存储于目标类型的常量表达式
- 从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非源是其值能完全存储于目标类型的常量表达式

示例：

```c++
int main() {
   int a = 1.2; // ok
   int b = {1.2}; // error

   float c = 1e70; // ok
   float d = {1e70}; // error

   float e = (unsigned long long)-1; // ok
   float f = {(unsigned long long)-1}; // error
   float g = (unsigned long long)1; // ok
   float h = {(unsigned long long)1}; // ok

   const int i = 1000;
   const int j = 2;
   char k = i; // ok
   char l = {i}; // error

   char m = j; // ok
   char m = {j}; // ok，因为是const类型，这里如果去掉const属性，也会报错
}
```

打印如下：

```
test.cc:24:17: error: narrowing conversion of ‘1.2e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]
    int b = {1.2};
                ^
test.cc:27:20: error: narrowing conversion of ‘1.0000000000000001e+70’ from ‘double’ to ‘float’ inside { } [-Wnarrowing]
     float d = {1e70};

test.cc:30:38: error: narrowing conversion of ‘18446744073709551615’ from ‘long long unsigned int’ to ‘float’ inside { } [-Wnarrowing]
    float f = {(unsigned long long)-1};
                                     ^
test.cc:36:14: warning: overflow in implicit constant conversion [-Woverflow]
    char k = i;
             ^
test.cc:37:16: error: narrowing conversion of ‘1000’ from ‘int’ to ‘char’ inside { } [-Wnarrowing]
    char l = {i};
```



## std::function & std::bind & lambda表达式

c++11新增了std::function、std::bind、lambda表达式等封装使函数调用更加方便，详细介绍请看：[搞定c++11新特性std::function和lambda表达式](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483968&idx=1&sn=3d1e0efb0a0cdc66bbf646fc5d64fcbe&chksm=eb7a04d3dc0d8dc56030fed11c83534c105d71f402f56bbb8ad75cb4b7ea4c5e25a6640c078b&scene=21#wechat_redirect)

c++11新增了std::function、std::bind、lambda表达式等封装使函数调用更加方便。

#### **std::function**

讲std::function前首先需要了解下什么是可调用对象

满足以下条件之一就可称为可调用对象：

- 是一个函数指针
- 是一个具有operator()成员函数的类对象(传说中的仿函数)，lambda表达式
- 是一个可被转换为函数指针的类对象
- 是一个类成员(函数)指针
- bind表达式或其它函数对象

而std::function就是上面这种可调用对象的封装器，可以把std::function看做一个函数对象，用于表示函数这个抽象概念。std::function的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为std::function的目标，若std::function不含目标，则称它为空，调用空的std::function的目标会抛出std::bad_function_call异常。

使用参考如下实例代码：

```c++
std::function<void(int)> f; // 这里表示function的对象f的参数是int，返回值是void
#include <functional>
#include <iostream>

struct Foo {
   Foo(int num) : num_(num) {}
   void print_add(int i) const { std::cout << num_ + i << '\n'; }
   int num_;
};

void print_num(int i) { std::cout << i << '\n'; }

struct PrintNum {
   void operator()(int i) const { std::cout << i << '\n'; }
};

int main() {
   // 存储自由函数
   std::function<void(int)> f_display = print_num;
   f_display(-9);

   // 存储 lambda
   std::function<void()> f_display_42 = []() { print_num(42); };
   f_display_42();

   // 存储到 std::bind 调用的结果
   std::function<void()> f_display_31337 = std::bind(print_num, 31337);
   f_display_31337();

   // 存储到成员函数的调用
   std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
   const Foo foo(314159);
   f_add_display(foo, 1);
   f_add_display(314159, 1);

   // 存储到数据成员访问器的调用
   std::function<int(Foo const&)> f_num = &Foo::num_;
   std::cout << "num_: " << f_num(foo) << '\n';

   // 存储到成员函数及对象的调用
   using std::placeholders::_1;
   std::function<void(int)> f_add_display2 = std::bind(&Foo::print_add, foo, _1);
   f_add_display2(2);

   // 存储到成员函数和对象指针的调用
   std::function<void(int)> f_add_display3 = std::bind(&Foo::print_add, &foo, _1);
   f_add_display3(3);

   // 存储到函数对象的调用
   std::function<void(int)> f_display_obj = PrintNum();
   f_display_obj(18);
}
```

从上面可以看到std::function的使用方法，当给std::function填入合适的参数表和返回值后，它就变成了可以容纳所有这一类调用方式的函数封装器。std::function还可以用作回调函数，或者在C++里如果需要使用回调那就一定要使用std::function，特别方便，这方面的使用方式大家可以读下我之前写的关于线程池和定时器相关的文章。

#### **std::bind**

使用std::bind可以将可调用对象和参数一起绑定，绑定后的结果使用std::function进行保存，并延迟调用到任何我们需要的时候。

std::bind通常有两大作用：

- 将可调用对象与参数一起绑定为另一个std::function供调用
- 将n元可调用对象转成m(m < n)元可调用对象，绑定一部分参数，这里需要使用std::placeholders

具体示例：

```c++
#include <functional>
#include <iostream>
#include <memory>

void f(int n1, int n2, int n3, const int& n4, int n5) {
   std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << std::endl;
}

int g(int n1) { return n1; }

struct Foo {
   void print_sum(int n1, int n2) { std::cout << n1 + n2 << std::endl; }
   int data = 10;
};

int main() {
   using namespace std::placeholders;  // 针对 _1, _2, _3...

   // 演示参数重排序和按引用传递
   int n = 7;
   // （ _1 与 _2 来自 std::placeholders ，并表示将来会传递给 f1 的参数）
   auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
   n = 10;
   f1(1, 2, 1001);  // 1 为 _1 所绑定， 2 为 _2 所绑定，不使用 1001
                    // 进行到 f(2, 42, 1, n, 7) 的调用

   // 嵌套 bind 子表达式共享占位符
   auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
   f2(10, 11, 12);  // 进行到 f(12, g(12), 12, 4, 5); 的调用

   // 绑定指向成员函数指针
   Foo foo;
   auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
   f3(5);

   // 绑定指向数据成员指针
   auto f4 = std::bind(&Foo::data, _1);
   std::cout << f4(foo) << std::endl;

   // 智能指针亦能用于调用被引用对象的成员
   std::cout << f4(std::make_shared<Foo>(foo)) << std::endl;
}
```

**lambda表达式**

lambda表达式可以说是c++11引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：

```c++
auto func = [capture] (params) opt -> ret { func_body; };
```

其中func是可以当作lambda表达式的名字，作为一个函数使用，capture是捕获列表，params是参数表，opt是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。

一个完整的lambda表达式：

```c++
auto func1 = [](int a) -> int { return a + 1; };
auto func2 = [](int a) { return a + 2; };
cout << func1(1) << " " << func2(2) << endl;
```

如上代码，很多时候lambda表达式返回值是很明显的，c++11允许省略表达式的返回值定义。

lambda表达式允许捕获一定范围内的变量：

- []不捕获任何变量
- [&]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用
- [=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用
- [=, &a]值捕获外部作用域所有变量，按引用捕获a变量
- [a]只值捕获a变量，不捕获其它变量
- [this]捕获当前类中的this指针

lambda表达式示例代码：

```c++
int a = 0;
auto f1 = [=](){ return a; }; // 值捕获a
cout << f1() << endl;

auto f2 = [=]() { return a++; }; // 修改按值捕获的外部变量，error
auto f3 = [=]() mutable { return a++; };
```

代码中的f2是编译不过的，因为我们修改了按值捕获的外部变量，其实lambda表达式就相当于是一个仿函数，仿函数是一个有operator()成员函数的类对象，这个operator()默认是const的，所以不能修改成员变量，而加了mutable，就是去掉const属性。

还可以使用lambda表达式自定义stl的规则，例如自定义sort排序规则：

```c++
struct A {
   int a;
   int b;
};

int main() {
   vector<A> vec;
   std::sort(vec.begin(), vec.end(), [](const A &left, const A &right) { return left.a < right.a; });
}
```

### **总结**

std::function和std::bind使得我们平时编程过程中封装函数更加的方便，而lambda表达式将这种方便发挥到了极致，可以在需要的时间就地定义匿名函数，不再需要定义类或者函数等，在自定义STL规则时候也非常方便，让代码更简洁，更灵活，提高开发效率。



## 模板的改进

C++11关于模板有一些细节的改进：

- 模板的右尖括号
- 模板的别名
- 函数模板的默认模板参数

详细介绍请看：[C++11的模板改进](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483929&idx=1&sn=7a2fac8daf54d12705ae6f36c57771ef&chksm=eb7a048adc0d8d9cd6ba448c6423ae167deca839965cf82ecec2a92d51b9cb325217689b0764&scene=21#wechat_redirect)

#### 模板的右尖括号

C++11之前是不允许两个右尖括号出现的，会被认为是右移操作符，所以需要中间加个空格进行分割，避免发生编译错误。

```c++
int main() {
   std::vector<std::vector<int>> a; // error
   std::vector<std::vector<int> > b; // ok
}
```

这个我之前都不知道，我开始学编程的时候就已经是C++11的时代啦。

### 模板的别名

C++11引入了using，可以轻松的定义别名，而不是使用繁琐的typedef。

```c++
typedef std::vector<std::vector<int>> vvi; // before c++11
using vvi = std::vector<std::vector<int>>; // c++11
```

使用using明显简洁并且易读，大家可能之前也见过使用typedef定义函数指针之类的操作，那烂代码我就不列出来了，反正我是看不懂也不想看...以后都可以使用using，额还是列出来吧。

```c++
typedef void (*func)(int, int); // 啥玩意，看不懂
using func = void (*)(int, int); // 起码比typedef容易看的懂吧
```

上面的代码使用using起码比typedef容易看的懂一些吧，但是我还是看不懂，因为我从来不用这种来表示函数指针，用std::function()、std::bind()、std::placeholder()、lambda表达式它不香吗。

### 函数模板的默认模板参数

C++11之前只有类模板支持默认模板参数，函数模板是不支持默认模板参数的，C++11后都支持。

```c++
template <typename T, typename U=int>
class A {
    T value;  
};

template <typename T=int, typename U> // error
class A {
    T value;  
};
```

类模板的默认模板参数必须从右往左定义，而函数模板则没有这个限制。

```c++
template <typename R, typename U=int>
R func1(U val) {
   return val;
}

template <typename R=int, typename U>
R func2(U val) {
   return val;
}

int main() {
   cout << func1<int, double>(99.9) << endl; // 99
   cout << func1<double, double>(99.9) << endl; // 99.9
   cout << func1<double>(99.9) << endl; // 99.9
   cout << func1<int>(99.9) << endl; // 99
   cout << func2<int, double>(99.9) << endl; // 99
   cout << func1<double, double>(99.9) << endl; // 99.9
   cout << func2<double>(99.9) << endl; // 99.9
   cout << func2<int>(99.9) << endl; // 99
   return 0;
}
```



## 并发

c++11关于并发引入了好多好东西，有：

- std::thread相关
- std::mutex相关
- std::lock相关
- std::atomic相关
- std::call_once相关
- volatile相关
- std::condition_variable相关
- std::future相关
- async相关

详细介绍请看：[c++11新特性之线程相关所有知识点](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483972&idx=1&sn=de4a41c7c7920241c35e76d25e092350&chksm=eb7a04d7dc0d8dc102d8400cb081f0a23ab231e36c7adff8c24bfc5cbcc73ac7389614167c95&scene=21#wechat_redirect)

这里也使用c++11来实现的线程池和定时器，可以看：

[C++线程池的实现之格式修订版](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483823&idx=1&sn=732303e36464f0c9fb4bd75fa10ba4db&chksm=eb7a073cdc0d8e2a6dca8babec94ce063ccab0c7832b9d85539357fe2da692fc6ad6cd5b938b&scene=21#wechat_redirect)

[C++定时器的实现之格式修订版](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483823&idx=2&sn=9d39ed7ef1d3bb6c2984db28aa013a9f&chksm=eb7a073cdc0d8e2a2e24291dc9c71d6c48bd8dd8e9149e91f10b44a75b10034005908de7b78d&scene=21#wechat_redirect)

#### std::thread相关

c++11之前你可能使用pthread_xxx来创建线程，繁琐且不易读，c++11引入了std::thread来创建线程，支持对线程join或者detach。直接看代码：

```c++
#include <iostream>
#include <thread>

using namespace std;

int main() {
   auto func = []() {
       for (int i = 0; i < 10; ++i) {
           cout << i << " ";
      }
       cout << endl;
  };
   std::thread t(func);
   if (t.joinable()) {
       t.detach();
  }
   auto func1 = [](int k) {
       for (int i = 0; i < k; ++i) {
           cout << i << " ";
      }
       cout << endl;
  };
   std::thread tt(func1, 20);
   if (tt.joinable()) { // 检查线程可否被join
       tt.join();
  }
   return 0;
}
```

上述代码中，函数func和func1运行在线程对象t和tt中，从刚创建对象开始就会新建一个线程用于执行函数，调用join函数将会阻塞主线程，直到线程函数执行结束，线程函数的返回值将会被忽略。如果不希望线程被阻塞执行，可以调用线程对象的detach函数，表示将线程和线程对象分离。

如果没有调用join或者detach函数，假如线程函数执行时间较长，此时线程对象的生命周期结束调用析构函数清理资源，这时可能会发生错误，这里有两种解决办法，一个是调用join()，保证线程函数的生命周期和线程对象的生命周期相同，另一个是调用detach()，将线程和线程对象分离，这里需要注意，如果线程已经和对象分离，那我们就再也无法控制线程什么时候结束了，不能再通过join来等待线程执行完。

这里可以对thread进行封装，避免没有调用join或者detach可导致程序出错的情况出现：

```c++
class ThreadGuard {
  public:
   enum class DesAction { join, detach };

   ThreadGuard(std::thread&& t, DesAction a) : t_(std::move(t)), action_(a){};
   ~ThreadGuard() {
       if (t_.joinable()) {
           if (action_ == DesAction::join) {
               t_.join();
           } else {
               t_.detach();
           }
  		 }
   }

   ThreadGuard(ThreadGuard&&) = default;
   ThreadGuard& operator=(ThreadGuard&&) = default;

   std::thread& get() { return t_; }
  private:
   std::thread t_;
   DesAction action_;
};

int main() {
   ThreadGuard t(std::thread([]() {
       for (int i = 0; i < 10; ++i) {
           std::cout << "thread guard " << i << " ";
       }
       std::cout << std::endl;}), ThreadGuard::DesAction::join);
   return 0;
}
```

c++11还提供了获取线程id，或者系统cpu个数，获取thread native_handle，使得线程休眠等功能

```c++
std::thread t(func);
cout << "当前线程ID " << t.get_id() << endl;
cout << "当前cpu个数 " << std::thread::hardware_concurrency() << endl;
auto handle = t.native_handle();// handle可用于pthread相关操作
std::this_thread::sleep_for(std::chrono::seconds(1));
```

#### std::mutex相关

std::mutex是一种线程同步的手段，用于保存多线程同时操作的共享数据。

mutex分为四种：

- std::mutex：独占的互斥量，不能递归使用，不带超时功能
- std::recursive_mutex：递归互斥量，可重入，不带超时功能
- std::timed_mutex：带超时的互斥量，不能递归
- std::recursive_timed_mutex：带超时的互斥量，可以递归使用

拿一个std::mutex和std::timed_mutex举例吧，别的都是类似的使用方式：

std::mutex:

```c++
#include <iostream>
#include <mutex>
#include <thread>

using namespace std;
std::mutex mutex_;

int main() {
   auto func1 = [](int k) {
       mutex_.lock();
       for (int i = 0; i < k; ++i) {
           cout << i << " ";
      }
       cout << endl;
       mutex_.unlock();
  };
   std::thread threads[5];
   for (int i = 0; i < 5; ++i) {
       threads[i] = std::thread(func1, 200);
  }
   for (auto& th : threads) {
       th.join();
  }
   return 0;
}
```

std::timed_mutex:

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <chrono>

using namespace std;
std::timed_mutex timed_mutex_;

int main() {
   auto func1 = [](int k) {
       timed_mutex_.try_lock_for(std::chrono::milliseconds(200));
       for (int i = 0; i < k; ++i) {
           cout << i << " ";
      }
       cout << endl;
       timed_mutex_.unlock();
  };
   std::thread threads[5];
   for (int i = 0; i < 5; ++i) {
       threads[i] = std::thread(func1, 200);
  }
   for (auto& th : threads) {
       th.join();
  }
   return 0;
}
```

#### std::lock相关

这里主要介绍两种RAII方式的锁封装，可以动态的释放锁资源，防止线程由于编码失误导致一直持有锁。

c++11主要有std::lock_guard和std::unique_lock两种方式，使用方式都类似，如下：

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <chrono>

using namespace std;
std::mutex mutex_;

int main() {
   auto func1 = [](int k) {
       // std::lock_guard<std::mutex> lock(mutex_);
       std::unique_lock<std::mutex> lock(mutex_);
       for (int i = 0; i < k; ++i) {
           cout << i << " ";
      }
       cout << endl;
   };
   std::thread threads[5];
   for (int i = 0; i < 5; ++i) {
       threads[i] = std::thread(func1, 200);
   }
   for (auto& th : threads) {
       th.join();
   }
   return 0;
}
```

std::lock_gurad相比于std::unique_lock更加轻量级，少了一些成员函数，std::unique_lock类有unlock函数，可以手动释放锁，所以条件变量都配合std::unique_lock使用，而不是std::lock_guard，因为条件变量在wait时需要有手动释放锁的能力，具体关于条件变量后面会讲到。

#### std::atomic相关

c++11提供了原子类型std::atomic<T>，理论上这个T可以是任意类型，但是我平时只存放整形，别的还真的没用过，整形有这种原子变量已经足够方便，就不需要使用std::mutex来保护该变量啦。看一个计数器的代码：

```c++
struct OriginCounter { // 普通的计数器
   int count;
   std::mutex mutex_;
   void add() {
       std::lock_guard<std::mutex> lock(mutex_);
       ++count;
  }

   void sub() {
       std::lock_guard<std::mutex> lock(mutex_);
       --count;
  }

   int get() {
       std::lock_guard<std::mutex> lock(mutex_);
       return count;
  }
};

struct NewCounter { // 使用原子变量的计数器
   std::atomic<int> count;
   void add() {
       ++count;
       // count.store(++count);这种方式也可以
  }

   void sub() {
       --count;
       // count.store(--count);
  }

   int get() {
       return count.load();
  }
};
```

是不是使用原子变量更加方便了呢？

#### std::call_once相关

c++11提供了std::call_once来保证某一函数在多线程环境中只调用一次，它需要配合std::once_flag使用，直接看使用代码吧：

```c++
std::once_flag onceflag;

void CallOnce() {
   std::call_once(onceflag, []() {
       cout << "call once" << endl;
  });
}

int main() {
   std::thread threads[5];
   for (int i = 0; i < 5; ++i) {
       threads[i] = std::thread(CallOnce);
   }
   for (auto& th : threads) {
       th.join();
   }
   return 0;
}
```

#### volatile相关

貌似把volatile放在并发里介绍不太合适，但是貌似很多人都会把volatile和多线程联系在一起，那就一起介绍下吧。

volatile通常用来建立内存屏障，volatile修饰的变量，编译器对访问该变量的代码通常不再进行优化，看下面代码：

```c++
int *p = xxx;
int a = *p;
int b = *p;
```

a和b都等于p指向的值，一般编译器会对此做优化，把*p的值放入寄存器，就是传说中的工作内存(不是主内存)，之后a和b都等于寄存器的值，但是如果中间p地址的值改变，内存上的值改变啦，但a,b还是从寄存器中取的值(不一定，看编译器优化结果)，这就不符合需求，所以在此对p加volatile修饰可以避免进行此类优化。

**注意：**volatile不能解决多线程安全问题，针对特种内存才需要使用volatile，它和atomic的特点如下：

• std::atomic用于多线程访问的数据，且不用互斥量，用于并发编程中

• volatile用于读写操作不可以被优化掉的内存，用于特种内存中



#### std::condition_variable相关

条件变量是c++11引入的一种同步机制，它可以阻塞一个线程或者多个线程，直到有线程通知或者超时才会唤醒正在阻塞的线程，条件变量需要和锁配合使用，这里的锁就是上面介绍的std::unique_lock。

这里使用条件变量实现一个CountDownLatch：

```c++
class CountDownLatch {
   public:
    explicit CountDownLatch(uint32_t count) : count_(count);

    void CountDown() {
        std::unique_lock<std::mutex> lock(mutex_);
        --count_;
        if (count_ == 0) {
            cv_.notify_all();
        }
    }

    void Await(uint32_t time_ms = 0) {
        std::unique_lock<std::mutex> lock(mutex_);
        while (count_ > 0) {
            if (time_ms > 0) {
                cv_.wait_for(lock, std::chrono::milliseconds(time_ms));
            } else {
                cv_.wait(lock);
            }
        }
    }

    uint32_t GetCount() const {
      std::unique_lock<std::mutex> lock(mutex_);
      return count_;
    }

   private:
    std::condition_variable cv_;
    mutable std::mutex mutex_;
    uint32_t count_ = 0;
};
```

关于条件变量其实还涉及到通知丢失和虚假唤醒问题，因为不是本文的主题，这里暂不介绍。

#### std::future相关

c++11关于异步操作提供了future相关的类，主要有std::future、std::promise和std::packaged_task，std::future比std::thread高级些，std::future作为异步结果的传输通道，通过get()可以很方便的获取线程函数的返回值，std::promise用来包装一个值，将数据和future绑定起来，而std::packaged_task则用来包装一个调用对象，将函数和future绑定起来，方便异步调用。而std::future是不可以复制的，如果需要复制放到容器中可以使用std::shared_future。

**std::promise与std::future配合使用**

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

void func(std::future<int>& fut) {
    int x = fut.get();
    cout << "value: " << x << endl;
}

int main() {
    std::promise<int> prom;
    std::future<int> fut = prom.get_future();
    std::thread t(func, std::ref(fut));
    prom.set_value(144);
    t.join();
    return 0;
}
```

**std::packaged_task与std::future配合使用**

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

int func(int in) {
    return in + 1;
}

int main() {
    std::packaged_task<int(int)> task(func);
    std::future<int> fut = task.get_future();
    std::thread(std::move(task), 5).detach();
    cout << "result " << fut.get() << endl;
    return 0;
}
```

更多关于future的使用可以看我之前写的关于线程池和定时器的文章。

**三者之间的关系**

std::future用于访问异步操作的结果，而std::promise和std::packaged_task在future高一层，它们内部都有一个future，promise包装的是一个值，packaged_task包装的是一个函数，当需要获取线程中的某个值，可以使用std::promise，当需要获取线程函数返回值，可以使用std::packaged_task。

#### async相关

async是比future，packaged_task，promise更高级的东西，它是基于任务的异步操作，通过async可以直接创建异步的任务，返回的结果会保存在future中，不需要像packaged_task和promise那么麻烦，关于线程操作应该优先使用async，看一段使用代码：

```c++
#include <functional>
#include <future>
#include <iostream>
#include <thread>

using namespace std;

int func(int in) { return in + 1; }

int main() {
    auto res = std::async(func, 5);
    // res.wait();
    cout << res.get() << endl; // 阻塞直到函数返回
    return 0;
}
```

使用async异步执行函数是不是方便多啦。

async具体语法如下：

```
async(std::launch::async | std::launch::deferred, func, args...);
```

第一个参数是创建策略：

- std::launch::async表示任务执行在另一线程
- std::launch::deferred表示延迟执行任务，调用get或者wait时才会执行，不会创建线程，惰性执行在当前线程。

如果不明确指定创建策略，以上两个都不是async的默认策略，而是未定义，它是一个基于任务的程序设计，内部有一个调度器(线程池)，会根据实际情况决定采用哪种策略。

若从 std::async 获得的 std::future 未被移动或绑定到引用，则在完整表达式结尾， std::future的析构函数将阻塞直至异步计算完成，实际上相当于同步操作：

```c++
std::async(std::launch::async, []{ f(); }); // 临时量的析构函数等待 f()
std::async(std::launch::async, []{ g(); }); // f() 完成前不开始
```

**注意：**关于async启动策略这里网上和各种书籍介绍的五花八门，这里会以cppreference为主。

• 有时候我们如果想真正执行异步操作可以对async进行封装，强制使用std::launch::async策略来调用async。

```c++
template <typename F, typename... Args>
inline auto ReallyAsync(F&& f, Args&&... params) {
    return std::async(std::launch::async, std::forward<F>(f), std::forward<Args>(params)...);
}
```

#### 总结

**•** std::thread使线程的创建变得非常简单，还可以获取线程id等信息。

**•** std::mutex通过多种方式保证了线程安全，互斥量可以独占，也可以重入，还可以设置互斥量的超时时间，避免一直阻塞等锁。

**•** std::lock通过RAII技术方便了加锁和解锁调用，有std::lock_guard和std::unique_lock。

**•** std::atomic提供了原子变量，更方便实现实现保护，不需要使用互斥量

**•** std::call_once保证函数在多线程环境下只调用一次，可用于实现单例。

**•** volatile常用于读写操作不可以被优化掉的内存中。

**•** std::condition_variable提供等待的同步机制，可阻塞一个或多个线程，等待其它线程通知后唤醒。

**•** std::future用于异步调用的包装和返回值。

**•** async更方便的实现了异步调用，异步调用优先使用async取代创建线程。



## 智能指针

很多人谈到c++，说它特别难，可能有一部分就是因为c++的内存管理吧，不像java那样有虚拟机动态的管理内存，在程序运行过程中可能就会出现内存泄漏，然而这种问题其实都可以通过c++11引入的智能指针来解决，相反我还认为这种内存管理还是c++语言的优势，因为尽在掌握。

c++11引入了三种智能指针：

- std::shared_ptr
- std::weak_ptr
- std::unique_ptr

详细介绍请看：[c++11新特性之智能指针](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483979&idx=1&sn=c815b28d8ffcb49adb7538bf76378f6d&chksm=eb7a04d8dc0d8dce96f262e0b14a74c0bc3a7bf335b202b4f404899489e7e1a325bc0b5b9068&scene=21#wechat_redirect)

#### shared_ptr

shared_ptr使用了引用计数，每一个shared_ptr的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次生命周期结束析构的时候引用计数-1，在最后一个shared_ptr析构的时候，内存才会释放。

使用方法如下：

```c++
struct ClassWrapper {
    ClassWrapper() {
        cout << "construct" << endl;
        data = new int[10];
    }
    ~ClassWrapper() {
        cout << "deconstruct" << endl;
        if (data != nullptr) {
            delete[] data;
        }
    }
    void Print() {
        cout << "print" << endl;
    }
    int* data;
};

void Func(std::shared_ptr<ClassWrapper> ptr) {
    ptr->Print();
}

int main() {
    auto smart_ptr = std::make_shared<ClassWrapper>();
    auto ptr2 = smart_ptr; // 引用计数+1
    ptr2->Print();
    Func(smart_ptr); // 引用计数+1
    smart_ptr->Print();
    ClassWrapper *p = smart_ptr.get(); // 可以通过get获取裸指针
    p->Print();
    return 0;
}
```

智能指针还可以自定义删除器，在引用计数为0的时候自动调用删除器来释放对象的内存，代码如下：

```c++
std::shared_ptr<int> ptr(new int, [](int *p){ delete p; });
```

**关于shared_ptr有几点需要注意：**

• 不要用一个裸指针初始化多个shared_ptr，会出现double_free导致程序崩溃

• 通过shared_from_this()返回this指针，不要把this指针作为shared_ptr返回出来，因为this指针本质就是裸指针，通过this返回可能 会导致重复析构，不能把this指针交给智能指针管理。

```c++
class A {
    shared_ptr<A> GetSelf() {
       return shared_from_this();
       // return shared_ptr<A>(this); 错误，会导致double free
    }  
};
```

- 尽量使用make_shared，少用new。
- 不要delete get()返回来的裸指针。
- 不是new出来的空间要自定义删除器。
- 要避免循环引用，循环引用导致内存永远不会被释放，造成内存泄漏。

```c++
using namespace std;
struct A;
struct B;

struct A {
   std::shared_ptr<B> bptr;
   ~A() {
       cout << "A delete" << endl;
  }
};

struct B {
   std::shared_ptr<A> aptr;
   ~B() {
       cout << "B delete" << endl;
   }
};

int main() {
   auto aaptr = std::make_shared<A>();
   auto bbptr = std::make_shared<B>();
   aaptr->bptr = bbptr;
   bbptr->aptr = aaptr;
   return 0;
}
```

上面代码，产生了循环引用，导致aptr和bptr的引用计数为2，离开作用域后aptr和bptr的引用计数-1，但是永远不会为0，导致指针永远不会析构，产生了内存泄漏，如何解决这种问题呢，答案是使用weak_ptr。



#### weak_ptr

weak_ptr是用来监视shared_ptr的生命周期，它不管理shared_ptr内部的指针，它的拷贝的析构都不会影响引用计数，纯粹是作为一个旁观者监视shared_ptr中管理的资源是否存在，可以用来返回this指针和解决循环引用问题。

- 作用1：返回this指针，上面介绍的shared_from_this()其实就是通过weak_ptr返回的this指针，这里参考我之前写的源码分析shared_ptr实现的文章，最后附上链接。
- 作用2：解决循环引用问题。

```C++
struct A;
struct B;

struct A {
   std::shared_ptr<B> bptr;
   ~A() {
       cout << "A delete" << endl;
   }
   void Print() {
       cout << "A" << endl;
   }
};

struct B {
   std::weak_ptr<A> aptr; // 这里改成weak_ptr
   ~B() {
       cout << "B delete" << endl;
   }
   void PrintA() {
       if (!aptr.expired()) { // 监视shared_ptr的生命周期
           auto ptr = aptr.lock();
           ptr->Print();
      }
   }
};

int main() {
   auto aaptr = std::make_shared<A>();
   auto bbptr = std::make_shared<B>();
   aaptr->bptr = bbptr;
   bbptr->aptr = aaptr;
   bbptr->PrintA();
   return 0;
}

输出：
A
A delete
B delete
```

#### unique_ptr

std::unique_ptr是一个独占型的智能指针，它不允许其它智能指针共享其内部指针，也不允许unique_ptr的拷贝和赋值。使用方法和shared_ptr类似，区别是不可以拷贝：

```c++
using namespace std;

struct A {
   ~A() {
       cout << "A delete" << endl;
   }
   void Print() {
       cout << "A" << endl;
   }
};


int main() {
   auto ptr = std::unique_ptr<A>(new A);
   auto tptr = std::make_unique<A>(); // error, c++11还不行，需要c++14
   std::unique_ptr<A> tem = ptr; // error, unique_ptr不允许移动
   ptr->Print();
   return 0;
}
```

unique_ptr也可以像shared_ptr一样自定义删除器，使用方法和shared_ptr相同。



## 其他小特性

#### 基于范围的for循环

```C++
vector<int> vec;

for (auto iter = vec.begin(); iter != vec.end(); iter++) { // before c++11
   cout << *iter << endl;
}

for (int i : vec) { // c++11基于范围的for循环
	cout << "i" << endl;
}
```

#### 委托构造函数  

委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作，通过代码来感受下委托构造函数的妙处吧：

不使用委托构造函数：

```C++
struct A {
   A(){}
   A(int a) { a_ = a; }

   A(int a, int b) { // 好麻烦
       a_ = a;
       b_ = b;
  }

   A(int a, int b, int c) { // 好麻烦
       a_ = a;
       b_ = b;
       c_ = c;
  }

   int a_;
   int b_;
   int c_;
};
```

使用委托构造函数：

```C++
struct A {
   A(){}
   A(int a) { a_ = a; }

   A(int a, int b) : A(a) { b_ = b; }

   A(int a, int b, int c) : A(a, b) { c_ = c; }

   int a_;
   int b_;
   int c_;
};
```

初始化变量是不是方便了许多。

#### 继承构造函数

继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数，老规矩，看代码：

不使用继承构造函数：

```C++
struct Base {
   Base() {}
   Base(int a) { a_ = a; }
   Base(int a, int b) : Base(a) { b_ = b; }
   Base(int a, int b, int c) : Base(a, b) { c_ = c; }

   int a_;
   int b_;
   int c_;
};

struct Derived : Base {
   Derived() {}
   Derived(int a) : Base(a) {} // 好麻烦
   Derived(int a, int b) : Base(a, b) {} // 好麻烦
   Derived(int a, int b, int c) : Base(a, b, c) {} // 好麻烦
};
int main() {
   Derived a(1, 2, 3);
   return 0;
}
```

使用继承构造函数：

```C++
struct Base {
   Base() {}
   Base(int a) { a_ = a; }
   Base(int a, int b) : Base(a) { b_ = b; }
   Base(int a, int b, int c) : Base(a, b) { c_ = c; }

   int a_;
   int b_;
   int c_;
};

struct Derived : Base {
   using Base::Base;
};

int main() {
   Derived a(1, 2, 3);
   return 0;
}
```

只需要使用using Base::Base继承构造函数，就免去了很多重写代码的麻烦。

#### nullptr

nullptr是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。举例：

```C++
void func(void *ptr) {
   cout << "func ptr" << endl;
}

void func(int i) {
   cout << "func i" << endl;
}

int main() {
   func(NULL); // 编译失败，会产生二义性
   func(nullptr); // 输出func ptr
   return 0;
}
```

#### final & override

c++11关于继承新增了两个关键字，final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。

示例代码1：

```C++
struct Base {
   virtual void func() {
       cout << "base" << endl;
  }
};

struct Derived : public Base{
   void func() override { // 确保func被重写
       cout << "derived" << endl;
   }

   void fu() override { // error，基类没有fu()，不可以被重写
   }
};
```

示例代码2：

```C++
struct Base final {
   virtual void func() {
       cout << "base" << endl;
  }
};

struct Derived : public Base{ // 编译失败，final修饰的类不可以被继承
   void func() override {
       cout << "derived" << endl;
  }
};
```

#### default

c++11引入default特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，如下代码：

```C++
struct A {
   int a;
   A(int i) { a = i; }
};

int main() {
   A a; // 编译出错
   return 0;
}
```

上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而通过default，程序员只需在函数声明后加上“`=default;`”，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，如下：

```C++
struct A {
   A() = default;
   int a;
   A(int i) { a = i; }
};

int main() {
   A a;
   return 0;
}
```

编译通过。

#### delete

c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，如下代码：

```c++
struct A {
   A() = default;
   int a;
   A(int i) { a = i; }
};

int main() {
   A a1;
   A a2 = a1;  // 正确，调用编译器隐式生成的默认拷贝构造函数
   A a3;
   a3 = a1;  // 正确，调用编译器隐式生成的默认拷贝赋值操作符
}
```

而我们有时候想禁止对象的拷贝与赋值，可以使用delete修饰，如下：

```c++
struct A {
   A() = default;
   A(const A&) = delete;
   A& operator=(const A&) = delete;
   int a;
   A(int i) { a = i; }
};

int main() {
   A a1;
   A a2 = a1;  // 错误，拷贝构造函数被禁用
   A a3;
   a3 = a1;  // 错误，拷贝赋值操作符被禁用
}
```

delele函数在c++11中很常用，std::unique_ptr就是通过delete修饰来禁止对象的拷贝的。

#### explicit

explicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看explicit的作用：

不用explicit：

```c++
struct A {
   A(int value) { // 没有explicit关键字
       cout << "value" << endl;
  }
};

int main() {
   A a = 1; // 可以隐式转换
   return 0;
}
```

使用explicit:

```c++
struct A {
   explicit A(int value) {
       cout << "value" << endl;
  }
};

int main() {
   A a = 1; // error，不可以隐式转换
   A aa(2); // ok
   return 0;
}
```

#### const

因为要讲后面的constexpr，所以这里简单介绍下const。

const字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。

主要用法如下：

1. 用于定义常量，const的修饰的变量不可更改。

```c++
const int value = 5;
```

2. 指针也可以使用const，这里有个小技巧，从右向左读，即可知道const究竟修饰的是指针还是指针所指向的内容。

```c++
char *const ptr; // 指针本身是常量
const char* ptr; // 指针指向的变量为常量
```

3. 在函数参数中使用const，一般会传递类对象时会传递一个const的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。

```c++
class A{};
void func(const A& a);
```

4. const修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。

 ```c++
 class A {
 const int value = 5;
 };
 class B {
 const int value;
 B(int v) : value(v){}
 };
 ```

5. 修饰类成员函数，表示在该函数内不可以修改该类的成员变量。

```c++
class A{
void func() const;
};
```

6. 修饰类对象，类对象只能调用该对象的const成员函数。

```c++
class A {
void func() const;
};
const A a;
a.func();
```

#### constexpr

constexpr是c++11新引入的关键字，用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：

两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码：

```c++
#include<iostream>
using namespace std;

constexpr int func(int i) {
   return i + 1;
}

int main() {
   int i = 2;
   func(i);// 普通函数
   func(2);// 编译期间就会被计算出来
}
```

#### enum class

c++11新增有作用域的枚举类型，看代码

不带作用域的枚举代码：

```c++
enum AColor {
   kRed,
   kGreen,
   kBlue
};

enum BColor {
   kWhite,
   kBlack,
   kYellow
};

int main() {
   if (kRed == kWhite) {
       cout << "red == white" << endl;
  }
   return 0;
}
```

如上代码，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的bug，而这种完全可以通过有作用域的枚举来规避。

有作用域的枚举代码：

```c++
enum class AColor {
   kRed,
   kGreen,
   kBlue
};

enum class BColor {
   kWhite,
   kBlack,
   kYellow
};

int main() {
   if (AColor::kRed == BColor::kWhite) { // 编译失败
       cout << "red == white" << endl;
  }
   return 0;
}
```

使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。

```c++
enum class AColor : char {
   kRed,
   kGreen,
   kBlue
};
```

我们平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。

#### 非受限联合体

c++11之前union中数据成员的类型不允许有非POD类型，而这个限制在c++11被取消，允许数据成员类型有非POD类型，看代码：

```c++
struct A {
   int a;
   int *b;
};

union U {
   A a; // 非POD类型 c++11之前不可以这样定义联合体
   int b;
};
```

对于什么是POD类型，大家可以自行查下资料，大体上可以理解为对象可以直接memcpy的类型。

#### sizeof

c++11中sizeof可以用的类的数据成员上，看代码：

c++11前：

```c++
struct A {
   int data[10];
   int a;
};

int main() {
   A a;
   cout << "size " << sizeof(a.data) << endl;
   return 0;
}
```

c++11后：

```c++
struct A {
   int data[10];
   int a;
};

int main() {
   cout << "size " << sizeof(A::data) << endl;
   return 0;
}
```

想知道类中数据成员的大小在c++11中是不是方便了许多，而不需要定义一个对象，在计算对象的成员大小。

#### assertion

static_assert(true/false, message);

c++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。



#### 自定义字面量

c++11可以自定义字面量，我们平时c++中都或多或少使用过chrono中的时间，例如：

```c++
std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 100ms
std::this_thread::sleep_for(std::chrono::seconds(100)); // 100s
```

其实没必要这么麻烦，也可以这么写：

```c++
std::this_thread::sleep_for(100ms); // c++14里可以这么使用，这里只是举个自定义字面量使用的例子
std::this_thread::sleep_for(100s);
```

这就是自定义字面量的使用，示例如下：

```c++
struct mytype {
   unsigned long long value;
};
constexpr mytype operator"" _mytype ( unsigned long long n ) {
   return mytype{n};
}
mytype mm = 123_mytype;
cout << mm.value << endl;
```

关于自定义字面量，可以看下chrono的源代码，相信大家会有很大收获，需要源码分析chrono的话，可以留言给我。

#### 内存对齐

##### 什么是内存对齐

理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数N的倍数，这就是内存对齐。

##### 为什么要内存对齐

1. 硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。
2. 提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。

在c++11之前如果想创建内存对齐需要：

```c++
void align_cpp11_before()
{
   static char data[sizeof(void *) + sizeof(A)];
   const uintptr_t kAlign = sizeof(void *) - 1;
   char *align_ptr = reinterpret_cast<char *>(reinterpret_cast<uintptr_t>(data + kAlign) & ~kAlign);
   A *attr = new (align_ptr) A;
}
```

c++11关于内存对齐新增了一些函数：

```c++
void align_cpp11_after()
{
   static std::aligned_storage<sizeof(A), alignof(A)>::type data;
   A *attr = new (&data) A;
}
```

还有：alignof()、std::alignment_of()、alignas()，关于内存对齐详情可以看这篇文章：[内存对齐之格式修订版](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483981&idx=1&sn=cfda6e84fd77084c75e5048187a1ab28&chksm=eb7a04dedc0d8dc8cb2a26e92f254e23a4538cd2756a1d7f0e8a2aaf99c6e18a42391208276f&scene=21#wechat_redirect)

#### thread_local

c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。

```c++
#include <iostream>
#include <thread>

class A {
  public:
   A() {}
   ~A() {}

   void test(const std::string &name) {
       thread_local int count = 0;
       ++count;
       std::cout << name << ": " << count << std::endl;
  }
};

void func(const std::string &name) {
   A a1;
   a1.test(name);
   a1.test(name);
   A a2;
   a2.test(name);
   a2.test(name);
}

int main() {
   std::thread(func, "thread1").join();
   std::thread(func, "thread2").join();
   return 0;
}
```

输出：

```
thread1: 1
thread1: 2
thread1: 3
thread1: 4
thread2: 1
thread2: 2
thread2: 3
thread2: 4
```

验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于static。

#### 基础数值类型

c++11新增了几种数据类型：long long、char16_t、char32_t等

#### 随机数功能

c++11关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，先看如下代码：

```c++
#include <time.h>
#include <iostream>
#include <random>

using namespace std;

int main() {
   std::default_random_engine random(time(nullptr));

   std::uniform_int_distribution<int> int_dis(0, 100); // 整数均匀分布
   std::uniform_real_distribution<float> real_dis(0.0, 1.0); // 浮点数均匀分布

   for (int i = 0; i < 10; ++i) {
       cout << int_dis(random) << ' ';
   }
   cout << endl;

   for (int i = 0; i < 10; ++i) {
       cout << real_dis(random) << ' ';
   }
   cout << endl;

   return 0;
}
```

输出：

```
38 100 93 7 66 0 68 99 41 7
0.232202 0.617716 0.959241 0.970859 0.230406 0.430682 0.477359 0.971858 0.0171148 0.64863
```

代码中举例的是整数均匀分布和浮点数均匀分布，c++11提供的概率分布类型还有好多，例如伯努利分布、正态分布等，具体可以见最后的参考资料。

#### 正则表达式

c++11引入了regex库更好的支持正则表达式，见代码：

```c++
#include <iostream>
#include <iterator>
#include <regex>
#include <string>

int main() {
   std::string s = "I know, I'll use2 regular expressions.";
	 // 忽略大小写
   std::regex self_regex("REGULAR EXPRESSIONS", std::regex_constants::icase);
   if (std::regex_search(s, self_regex)) {
       std::cout << "Text contains the phrase 'regular expressions'\n";
   }

   std::regex word_regex("(\\w+)");  // 匹配字母数字等字符
   auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex);
   auto words_end = std::sregex_iterator();

   std::cout << "Found " << std::distance(words_begin, words_end) << " words\n";

   const int N = 6;
   std::cout << "Words longer than " << N << " characters:\n";
   for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
       std::smatch match = *i;
       std::string match_str = match.str();
       if (match_str.size() > N) {
           std::cout << " " << match_str << '\n';
      }
  }

   std::regex long_word_regex("(\\w{7,})");
   // 超过7个字符的单词用[]包围
   std::string new_s = std::regex_replace(s, long_word_regex, "[$&]");
   std::cout << new_s << '\n';
}
```

#### chrono

c++11关于时间引入了chrono库，源于boost，功能强大，chrono主要有三个点：

- duration
- time_point
- clocks

##### duration

std::chrono::duration表示一段时间，常见的单位有s、ms等，示例代码：

```
// 拿休眠一段时间举例，这里表示休眠100ms
std::this_thread::sleep_for(std::chrono::milliseconds(100));
```

sleep_for里面其实就是std::chrono::duration，表示一段时间，实际是这样：

```c++
typedef duration<int64_t, milli> milliseconds;
typedef duration<int64_t> seconds;
```

duration具体模板如下：

```c++
template <class Rep, class Period = ratio<1> > class duration;
```

Rep表示一种数值类型，用来表示Period的数量，比如int、float、double，Period是ratio类型，用来表示【用秒表示的时间单位】比如second，常用的duration<Rep, Period>已经定义好了，在std::chrono::duration下：

- ratio<3600, 1>：hours
- ratio<60, 1>：minutes
- ratio<1, 1>：seconds
- ratio<1, 1000>：microseconds
- ratio<1, 1000000>：microseconds
- ratio<1, 1000000000>：nanosecons

ratio的具体模板如下：

```c++
template <intmax_t N, intmax_t D = 1> class ratio;
```

N代表分子，D代表分母，所以ratio表示一个分数，我们可以自定义Period，比如ratio<2, 1>表示单位时间是2秒。

##### time_point

表示一个具体时间点，如2020年5月10日10点10分10秒，拿获取当前时间举例：

```c++
std::chrono::time_point<std::chrono::high_resolution_clock> Now() {
   return std::chrono::high_resolution_clock::now();
}
// std::chrono::high_resolution_clock为高精度时钟，下面会提到
```

**clocks**

时钟，chrono里面提供了三种时钟：

- steady_clock
- system_clock
- high_resolution_clock

##### steady_clock

稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用now()肯定比前一次调用now()的数值大，可用于计时。

##### system_clock

表示当前的系统时钟，可以用于获取当前时间：

```c++
int main() {
   using std::chrono::system_clock;
   system_clock::time_point today = system_clock::now();

   std::time_t tt = system_clock::to_time_t(today);
   std::cout << "today is: " << ctime(&tt);

   return 0;
}
// today is: Sun May 10 09:48:36 2020
```

**high_resolution_clock**

high_resolution_clock表示系统可用的最高精度的时钟，实际上就是system_clock或者steady_clock其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样，我之前看gcc chrono源码中high_resolution_clock是steady_clock的typedef。

更多关于chrono的介绍可以看下我之前的文章：[RAII妙用之计算函数耗时](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247483852&idx=1&sn=34dde853d5304f8a165e82effe287f3c&chksm=eb7a075fdc0d8e4971f55dc3c4ad4388a3c7466c6df5a47bcfa81510de230cf22065298fee26&scene=21#wechat_redirect)

#### 新增数据结构

- std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存，提高了性能

```c++
std::forward_list<int> fl = {1, 2, 3, 4, 5};
for (const auto &elem : fl) {
   cout << elem;
}
```

- std::unordered_set：基于hash表实现的set，内部不会排序，使用方法和set类似
- std::unordered_map：基于hash表实现的map，内部不会排序，使用方法和set类似
- std::array：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组
- std::tuple：元组类型，类似pair，但比pair扩展性好

```c++
typedef std::tuple<int, double, int, double> Mytuple;
Mytuple t(0, 1, 2, 3);
std::cout << "0 " << std::get<0>(t);
std::cout << "1 " << std::get<1>(t);
std::cout << "2 " << std::get<2>(t);
std::cout << "3 " << std::get<3>(t);
```

**新增算法**

- all_of：检测表达式是否对范围[first, last)中所有元素都返回true，如果都满足，则返回true

```c++
std::vector<int> v(10, 2);
if (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; })) {
	std::cout << "All numbers are even\n";
}
```

- any_of：检测表达式是否对范围[first, last)中至少一个元素返回true，如果满足，则返回true，否则返回false，用法和上面一样
- none_of：检测表达式是否对范围[first, last)中所有元素都不返回true，如果都不满足，则返回true，否则返回false，用法和上面一样
- find_if_not：找到第一个不符合要求的元素迭代器，和find_if相反
- copy_if：复制满足条件的元素
- itoa：对容器内的元素按序递增

```c++
std::vector<int> l(10);
std::iota(l.begin(), l.end(), 19); // 19为初始值
for (auto n : l) std::cout << n << ' ';
// 19 20 21 22 23 24 25 26 27 28
```

- minmax_element：返回容器内最大元素和最小元素位置

```c++
int main() {
   std::vector<int> v = {3, 9, 1, 4, 2, 5, 9};

   auto result = std::minmax_element(v.begin(), v.end());
   std::cout << "min element at: " << *(result.first) << '\n';
   std::cout << "max element at: " << *(result.second) << '\n';
   return 0;
}
// min element at: 1
// max element at: 9
```

- is_sorted、is_sorted_until：返回容器内元素是否已经排好序。

关于c++11的新特性基本上就是这些，相信各位看完一定会有所收获。

### 参考资料

> https://zh.cppreference.com/w/cpp/language/range-for

> https://juejin.im/post/5dcaa857e51d457f7675360b

> https://zhuanlan.zhihu.com/p/21930436

> https://zh.wikipedia.org/wiki/Nullptr

> https://zh.wikipedia.org/wiki/Constexpr

> https://zh.cppreference.com/w/cpp/language/enum

> https://kheresy.wordpress.com/2019/03/27/using-enum-class/

> https://zh.cppreference.com/w/cpp/language/union

> http://c.biancheng.net/view/7165.html

> https://zhuanlan.zhihu.com/p/77585472

> http://www.cplusplus.com/reference/random/

> https://zh.cppreference.com/w/cpp/regex

> https://www.cnblogs.com/jwk000/p/3560086.html

> https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of



# C++14新特性

## **「函数返回值类型推导」**

C++14对函数返回类型推导规则做了优化，先看一段代码：

```c++
#include <iostream>

using namespace std;

auto func(int i) {
   return i;
}

int main() {
   cout << func(4) << endl;
   return 0;
}
```

使用C++11编译：

```
~/test$ g++ test.cc -std=c++11
test.cc:5:16: error: ‘func’ function uses ‘auto’ type specifier without trailing return type
auto func(int i) {
               ^
test.cc:5:16: note: deduced return type only available with -std=c++14 or -std=gnu++14
```

上面的代码使用C++11是不能通过编译的，通过编译器输出的信息也可以看见这个特性需要到C++14才被支持。

返回值类型推导也可以用在模板中：

```
#include <iostream>
using namespace std;

template<typename T> auto func(T t) { return t; }

int main() {
   cout << func(4) << endl;
   cout << func(3.4) << endl;
   return 0;
}
```

**注意**：

**函数内如果有多个return语句，它们必须返回相同的类型，否则编译失败**

```c++
auto func(bool flag) {
   if (flag) return 1;
   else return 2.3; // error
}
// inconsistent deduction for auto return type: ‘int’ and then ‘double’
```

**如果return语句返回初始化列表，返回值类型推导也会失败**

```c++
auto func() {
   return {1, 2, 3}; // error returning initializer list
}
```

**如果函数是虚函数，不能使用返回值类型推导**

```c++
struct A {
// error: virtual function cannot have deduced return type
virtual auto func() { return 1; }
}
```

**返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义**

```c++
auto f();               // declared, not yet defined
auto f() { return 42; } // defined, return type is int

int main() {
	cout << f() << endl;
}
```

**返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。**

```c++
auto sum(int i) {
   if (i == 1)
       return i;              // return int
   else
       return sum(i - 1) + i; // ok
}
```

**lambda参数auto**

在C++11中，lambda表达式参数需要使用具体的类型声明：

```c++
auto f = [] (int a) { return a; }
```

在C++14中，对此进行优化，lambda表达式参数可以直接是auto：

```c++
auto f = [] (auto a) { return a; };
cout << f(1) << endl;
cout << f(2.3f) << endl;
```



**变量模板**

C++14支持变量模板：

```C++
template<class T>
constexpr T pi = T(3.1415926535897932385L);

int main() {
   cout << pi<int> << endl; // 3
   cout << pi<double> << endl; // 3.14159
   return 0;
}
```

**别名模板**

C++14也支持别名模板：

```C++
template<typename T, typename U>
struct A {
   T t;
   U u;
};

template<typename T>
using B = A<T, int>;

int main() {
   B<double> b;
   b.t = 10;
   b.u = 20;
   cout << b.t << endl;
   cout << b.u << endl;
   return 0;
}
```



**constexpr的限制**

C++14相较于C++11对constexpr减少了一些限制：

**C++11中constexpr函数可以使用递归，在C++14中可以使用局部变量和循环**

```C++
constexpr int factorial(int n) { // C++14 和 C++11均可
   return n <= 1 ? 1 : (n * factorial(n - 1));
}
```

在C++14中可以这样做：

```C++
constexpr int factorial(int n) { // C++11中不可，C++14中可以
   int ret = 0;
   for (int i = 0; i < n; ++i) {
       ret += i;
  }
   return ret;
}
```

**C++11中constexpr函数必须必须把所有东西都放在一个单独的return语句中，而constexpr则无此限制**

```C++
constexpr int func(bool flag) { // C++14 和 C++11均可
   return 0;
}
```

在C++14中可以这样：

```c++
constexpr int func(bool flag) { // C++11中不可，C++14中可以
   if (flag) return 1;
   else return 0;
}
```



**[[deprecated]]标记**

C++14中增加了deprecated标记，修饰类、变、函数等，当程序中使用到了被其修饰的代码时，编译时被产生警告，用户提示开发者该标记修饰的内容将来可能会被丢弃，尽量不要使用。

```c++
struct [[deprecated]] A { };

int main() {
    A a;
    return 0;
}
```

当编译时，会出现如下警告：

```c++
~/test$ g++ test.cc -std=c++14
test.cc: In function ‘int main()’:
test.cc:11:7: warning: ‘A’ is deprecated [-Wdeprecated-declarations]
     A a;
       ^
test.cc:6:23: note: declared here
 struct [[deprecated]] A {
```



**二进制字面量与整形字面量分隔符**

C++14引入了二进制字面量，也引入了分隔符，防止看起来眼花哈~

```
int a = 0b0001'0011'1010;
double b = 3.14'1234'1234'1234;
```

**std::make_unique**

我们都知道C++11中有std::make_shared，却没有std::make_unique，在C++14已经改善。

```C++
struct A {};
std::unique_ptr<A> ptr = std::make_unique<A>();
```



**std::shared_timed_mutex与std::shared_lock**

C++14通过std::shared_timed_mutex和std::shared_lock来实现读写锁，保证多个线程可以同时读，但是写线程必须独立运行，写操作不可以同时和读操作一起进行。

实现方式如下：

```C++
struct ThreadSafe {
    mutable std::shared_timed_mutex mutex_;
    int value_;

    ThreadSafe() {
        value_ = 0;
    }

    int get() const {
        std::shared_lock<std::shared_timed_mutex> loc(mutex_);
        return value_;
    }

    void increase() {
        std::unique_lock<std::shared_timed_mutex> lock(mutex_);
        value_ += 1;
    }
};
```

为什么是timed的锁呢，因为可以带超时时间，具体可以自行查询相关资料哈，网上有很多。



**std::integer_sequence**

```c++
template<typename T, T... ints>
void print_sequence(std::integer_sequence<T, ints...> int_seq)
{
    std::cout << "The sequence of size " << int_seq.size() << ": ";
    ((std::cout << ints << ' '), ...);
    std::cout << '\n';
}

int main() {
    print_sequence(std::integer_sequence<int, 9, 2, 5, 1, 9, 1, 6>{});
    return 0;
}

输出：7 9 2 5 1 9 1 6
```

std::integer_sequence和std::tuple的配合使用：

```c++
template <std::size_t... Is, typename F, typename T>
auto map_filter_tuple(F f, T& t) {
    return std::make_tuple(f(std::get<Is>(t))...);
}

template <std::size_t... Is, typename F, typename T>
auto map_filter_tuple(std::index_sequence<Is...>, F f, T& t) {
    return std::make_tuple(f(std::get<Is>(t))...);
}

template <typename S, typename F, typename T>
auto map_filter_tuple(F&& f, T& t) {
    return map_filter_tuple(S{}, std::forward<F>(f), t);
}
```



**std::exchange**

直接看代码吧：

```c++
int main() {
    std::vector<int> v;
    std::exchange(v, {1,2,3,4});
    cout << v.size() << endl;
    for (int a : v) {
        cout << a << " ";
    }
    return 0;
}
```

看样子貌似和std::swap作用相同，那它俩有什么区别呢？

可以看下exchange的实现：

```c++
template<class T, class U = T>
constexpr T exchange(T& obj, U&& new_value) {
    T old_value = std::move(obj);
    obj = std::forward<U>(new_value);
    return old_value;
}
```

可以看见new_value的值给了obj，而没有对new_value赋值，这里相信您已经知道了它和swap的区别了吧！

**std::quoted**

C++14引入std::quoted用于给字符串添加双引号，直接看代码：

```C++
int main() {
    string str = "hello world";
    cout << str << endl;
    cout << std::quoted(str) << endl;
    return 0;
}
```

编译&输出：

```
~/test$ g++ test.cc -std=c++14
~/test$ ./a.out
hello world
"hello world"
```



# C++17

**主要新特性如下：**

- 构造函数模板推导
- 结构化绑定
- if-switch语句初始化
- 内联变量
- 折叠表达式
- constexpr lambda表达式
- namespace嵌套
- __has_include预处理表达式
- 在lambda表达式用*this捕获对象副本
- 新增Attribute
- 字符串转换
- std::variant
- std::optional
- std::any
- std::apply
- std::make_from_tuple
- as_const
- std::string_view
- file_system
- std::shared_mutex

#### 构造函数模板推导

在C++17前构造一个模板类对象需要指明类型：

```c++
pair<int, double> p(1, 2.2); // before c++17

pair p(1, 2.2); // c++17 自动推导
vector v = {1, 2, 3}; // c++17
```



**结构化绑定**

通过结构化绑定，对于tuple、map等类型，获取相应值会方便很多，看代码：

```c++
std::tuple<int, double> func() {
   return std::tuple(1, 2.2);
}

int main() {
   auto[i, d] = func(); //是C++11的tie吗？更高级
   cout << i << endl;
   cout << d << endl;
}

//==========================
void f() {
   map<int, string> m = {
    {0, "a"},
    {1, "b"},  
   };
   for (const auto &[i, s] : m) {
       cout << i << " " << s << endl;
   }
}

// ====================
int main() {
   std::pair a(1, 2.3f);
   auto[i, f] = a;
   cout << i << endl; // 1
   cout << f << endl; // 2.3f
   return 0;
}
```

结构化绑定还可以改变对象的值，使用引用即可：

```c++
// 进化，可以通过结构化绑定改变对象的值
int main() {
   std::pair a(1, 2.3f);
   auto& [i, f] = a;
   i = 2;
   cout << a.first << endl; // 2
}
```

*注意结构化绑定不能应用于constexpr*

constexpr auto[x, y] = std::pair(1, 2.3f); *// compile error, C++20可以*

结构化绑定不止可以绑定pair和tuple，还可以绑定数组和结构体等。

```c++
int array[3] = {1, 2, 3};
auto [a, b, c] = array;
cout << a << " " << b << " " << c << endl;

// 注意这里的struct的成员一定要是public的
struct Point {
   int x;
   int y;
};
Point func() {
   return {1, 2};
}
const auto [x, y] = func();
```

这里其实可以实现自定义类的结构化绑定，代码如下：

```c++
// 需要实现相关的tuple_size和tuple_element和get<N>方法。
class Entry {
public:
   void Init() {
       name_ = "name";
       age_ = 10;
  }

   std::string GetName() const { return name_; }
   int GetAge() const { return age_; }
private:
   std::string name_;
   int age_;
};

template <size_t I>
auto get(const Entry& e) {
   if constexpr (I == 0) return e.GetName();
   else if constexpr (I == 1) return e.GetAge();
}

namespace std {
   template<> struct tuple_size<Entry> : integral_constant<size_t, 2> {};
   template<> struct tuple_element<0, Entry> { using type = std::string; };
   template<> struct tuple_element<1, Entry> { using type = int; };
}

int main() {
   Entry e;
   e.Init();
   auto [name, age] = e;
   cout << name << " " << age << endl; // name 10
   return 0;
}
```



**if-switch语句初始化**

C++17前if语句需要这样写代码：

```c++
// before 17
int a = GetValue();
if (a < 101) {
   cout << a;
}

// after 17
// if (init; condition)
if (int a = GetValue()); a < 101) {
   cout << a;
}

string str = "Hi World";
if (auto [pos, size] = pair(str.find("Hi"), str.size()); pos != string::npos) {
   std::cout << pos << " Hello, size is " << size;
}
```

使用这种方式可以尽可能约束作用域，让代码更简洁，但是可读性略有下降。



#### **内联变量**

C++17前只有内联函数，现在有了内联变量，我们印象中C++类的静态成员变量在头文件中是不能初始化的，但是有了内联变量，就可以达到此目的：

```C++
// header file
struct A {
   static const int value;  
};
inline int const A::value = 10;

// ==========或者========
struct A {
   inline static const int value = 10;
}
```



**折叠表达式**

C++17引入了折叠表达式使可变参数模板编程更方便：

```C++
template <typename ... Ts>
auto sum(Ts ... ts) {
   return (ts + ...);
}
int a {sum(1, 2, 3, 4, 5)}; // 15
std::string a{"hello "};
std::string b{"world"};
cout << sum(a, b) << endl; // hello world
```



**constexpr lambda表达式**

C++17前lambda表达式只能在运行时使用，C++17引入了constexpr lambda表达式，可以用于在编译期进行计算。

```C++
int main() { // c++17可编译
   constexpr auto lamb = [] (int n) { return n * n; };
   static_assert(lamb(3) == 9, "a");
}
```

**注意**

constexpr函数有如下限制：

函数体不能包含汇编语句、goto语句、label、try块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有new delete等，不能虚函数。



#### **namespace嵌套**

```C++
namespace A {
   namespace B {
       namespace C {
           void func();
      }
  }
}

// c++17，更方便更舒适
namespace A::B::C {
   void func();)
}
```



**__has_include预处理表达式**

可以判断是否有某个头文件，代码可能会在不同编译器下工作，不同编译器的可用头文件有可能不同，所以可以使用此来判断：

```C++
#if defined __has_include
#if __has_include(<charconv>)
#define has_charconv 1
#include <charconv>
#endif
#endif

std::optional<int> ConvertToInt(const std::string& str) {
   int value{};
#ifdef has_charconv
   const auto last = str.data() + str.size();
   const auto res = std::from_chars(str.data(), last, value);
   if (res.ec == std::errc{} && res.ptr == last) return value;
#else
   // alternative implementation...
   其它方式实现
#endif
   return std::nullopt;
}
```



**在lambda表达式用\*this捕获对象副本**

正常情况下，lambda表达式中访问类的对象成员变量需要捕获this，但是这里捕获的是this指针，指向的是对象的引用，正常情况下可能没问题，但是如果多线程情况下，函数的作用域超过了对象的作用域，对象已经被析构了，还访问了成员变量，就会有问题。

```C++
struct A {
   int a;
   void func() {
       auto f = [this] {
           cout << a << endl;
       };
       f();
   }  
};
int main() {
   A a;
   a.func();
   return 0;
}
```

所以C++17增加了新特性，捕获*this，不持有this指针，而是持有对象的拷贝，这样生命周期就与对象的生命周期不相关啦。



**新增Attribute**

我们可能平时在项目中见过__declspec__**,** __attribute__ , #pragma指示符，使用它们来给编译器提供一些额外的信息，来产生一些优化或特定的代码，也可以给其它开发者一些提示信息。

**例如：**

```C++
struct A { short f[3]; } __attribute__((aligned(8)));

void fatal() __attribute__((noreturn));
```

在C++11和C++14中有更方便的方法：

```C++
[[carries_dependency]] 让编译期跳过不必要的内存栅栏指令
[[noreturn]] 函数不会返回
[[deprecated]] 函数将弃用的警告

[[noreturn]] void terminate() noexcept;
[[deprecated("use new func instead")]] void func() {}
```

C++17又新增了三个：

**[[fallthrough]]**：用在switch中提示可以直接落下去，不需要break，让编译期忽略警告

```C++
switch (i) {}
    case 1:
        xxx; // warning
    case 2:
        xxx;
        [[fallthrough]];      // 警告消除
    case 3:
        xxx;
       break;
}
```

使得编译器和其它开发者都可以理解开发者的意图。

**[[nodiscard]]** ：表示修饰的内容不能被忽略，可用于修饰函数，标明返回值一定要被处理

```c++
[[nodiscard]] int func();
void F() {
    func(); // warning 没有处理函数返回值
}
```

**[[maybe_unused]]** ：提示编译器修饰的内容可能暂时没有使用，避免产生警告

```c++
void func1() {}
[[maybe_unused]] void func2() {} // 警告消除
void func3() {
    int x = 1;
    [[maybe_unused]] int y = 2; // 警告消除
}
```



**字符串转换**

新增from_chars函数和to_chars函数，直接看代码：

```C++
#include <charconv>

int main() {
    const std::string str{"123456098"};
    int value = 0;
    const auto res = std::from_chars(str.data(), str.data() + 4, value);
    if (res.ec == std::errc()) {
        cout << value << ", distance " << res.ptr - str.data() << endl;
    } else if (res.ec == std::errc::invalid_argument) {
        cout << "invalid" << endl;
    }
    str = std::string("12.34);
    double val = 0;
    const auto format = std::chars_format::general;
    res = std::from_chars(str.data(), str.data() + str.size(), value, format);

    str = std::string("xxxxxxxx");
    const int v = 1234;
    res = std::to_chars(str.data(), str.data() + str.size(), v);
    cout << str << ", filled " << res.ptr - str.data() << " characters \n";
    // 1234xxxx, filled 4 characters
}
```



**std::variant**

C++17增加std::variant实现类似union的功能，但却比union更高级，举个例子union里面不能有string这种类型，但std::variant却可以，还可以支持更多复杂类型，如map等，看代码：

````c++
int main() { // c++17可编译
    std::variant<int, std::string> var("hello");
    cout << var.index() << endl;
    var = 123;
    cout << var.index() << endl;

    try {
        var = "world";
        std::string str = std::get<std::string>(var); // 通过类型获取值
        var = 3;
        int i = std::get<0>(var); // 通过index获取对应值
        cout << str << endl;
        cout << i << endl;
    } catch(...) {
        // xxx;
    }
    return 0;
}
````

**注意**

一般情况下variant的第一个类型一般要有对应的构造函数，否则编译失败：

```c++
struct A {
    A(int i){}
};
int main() {
    std::variant<A, int> var; // 编译失败
}
```

如何避免这种情况呢，可以使用std::monostate来打个桩，模拟一个空状态。

std::variant<std::monostate, A> var; *// 可以编译成功*



**std::optional**

我们有时候可能会有需求，让函数返回一个对象，如下：

```c++
struct A {};
A func() {
    if (flag) return A();
    else {
        // 异常情况下，怎么返回异常值呢，想返回个空呢
    }
}
```

有一种办法是返回对象指针，异常情况下就可以返回nullptr啦，但是这就涉及到了内存管理，也许你会使用智能指针，但这里其实有更方便的办法就是std::optional。

```c++
std::optional<int> StoI(const std::string &s) {
    try {
        return std::stoi(s);
    } catch(...) {
        return std::nullopt;
    }
}

void func() {
    std::string s{"123"};
    std::optional<int> o = StoI(s);
    if (o) {
        cout << *o << endl;
    } else {
        cout << "error" << endl;
    }
}
```



**std::any**

C++17引入了any可以存储任何类型的单个值，见代码：

```c++
int main() { // c++17可编译
    std::any a = 1;
    cout << a.type().name() << " " << std::any_cast<int>(a) << endl;
    a = 2.2f;
    cout << a.type().name() << " " << std::any_cast<float>(a) << endl;
    if (a.has_value()) {
        cout << a.type().name();
    }
    a.reset();
    if (a.has_value()) {
        cout << a.type().name();
    }
    a = std::string("a");
    cout << a.type().name() << " " << std::any_cast<std::string>(a) << endl;
    return 0;
}
```



**std::apply**

使用std::apply可以将tuple展开作为函数的参数传入，见代码：

```c++
int add(int first, int second) { return first + second; }

auto add_lambda = [](auto first, auto second) { return first + second; };

int main() {
    std::cout << std::apply(add, std::pair(1, 2)) << '\n';
    std::cout << add(std::pair(1, 2)) << "\n"; // error
    std::cout << std::apply(add_lambda, std::tuple(2.0f, 3.0f)) << '\n';
}
```

**std::make_from_tuple**

使用make_from_tuple可以将tuple展开作为构造函数参数

```C++
struct Foo {
    Foo(int first, float second, int third) {
        std::cout << first << ", " << second << ", " << third << "\n";
    }
};
int main() {
   auto tuple = std::make_tuple(42, 3.14f, 0);
   std::make_from_tuple<Foo>(std::move(tuple));
}
```



**std::string_view**

通常我们传递一个string时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了string_view就可以避免拷贝操作，平时传递过程中传递string_view即可。

```C++
void func(std::string_view stv) { cout << stv << endl; }

int main(void) {
    std::string str = "Hello World";
    std::cout << str << std::endl;

    std::string_view stv(str.c_str(), str.size());
    cout << stv << endl;
    func(stv);
    return 0;
}
```



**as_const**

C++17使用as_const可以将左值转成const类型

```C++
std::string str = "str";
const std::string& constStr = std::as_const(str);
```



**file_system**

C++17正式将file_system纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：

```C++
namespace fs = std::filesystem;
fs::create_directory(dir_path);
fs::copy_file(src, dst, fs::copy_options::skip_existing);
fs::exists(filename);
fs::current_path(err_code);
```



**std::shared_mutex**

C++17引入了shared_mutex，可以实现读写锁，具体可以见我上一篇文章：[C++14新特性的所有知识点全在这儿啦！](http://mp.weixin.qq.com/s?__biz=MzI3NjA1OTEzMg==&mid=2247484220&idx=1&sn=37181aeec58bd5cdbf15e433f6427c13&chksm=eb7a05afdc0d8cb971719131a6601885400d066cc77082bf7eb3f8a708fe83a7ea7aeb087982&scene=21#wechat_redirect)

关于C++17的介绍就到这里，希望对大家有所帮助~

#### 参考资料

> https://en.cppreference.com/w/cpp/utility/make_from_tuple

> https://en.cppreference.com/w/cpp/utility/apply

> https://en.cppreference.com/w/cpp/17

> https://cloud.tencent.com/developer/article/1383177

> https://www.jianshu.com/p/9b8eeddbf1e4













