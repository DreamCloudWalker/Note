### 1. 指针和引用的区别

（1）指针有自己的一块空间，而引用只是一个别名；

（2）使用 sizeof 看一个指针的大小为4字节（32位，如果要是64位的话指针为8字节），而引用则是被引用对象的大小。

（3）指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用。

（4）作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象。

（5）指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变。

（6）指针可以是多级，而引用没有分级

（7）如果返回动态分配内存的对象或者内存，必须使用指针，引用可能引起内存泄漏。



### 2. new 和 delete 是如何实现的，与 malloc 和 free有什么异同？

**new操作针对数据类型的处理，分为两种情况：**

（1） 简单数据类型（包括基本数据类型和不需要构造函数的类型）

* 简单类型直接调用 operator new 分配内存；

* 可以通过new_handler 来处理 new 失败的情况；

* new 分配失败的时候不像 malloc 那样返回 NULL，它直接抛出异常（bad_alloc）。要判断是否分配成功应该用异常捕获的机制；



（2）复杂数据类型（需要由构造函数初始化对象）

* new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数



**delete也分为两种情况：**

（1） 简单数据类型（包括基本数据类型和不需要析构函数的类型）

*  delete简单数据类型默认只是调用free函数。



（2）复杂数据类型（需要由析构函数销毁对象）

* delete复杂数据类型先调用析构函数再调用operator delete。



***与malloc 和 free 的区别：***

（1）属性上：new / delete 是c++关键字，需要编译器支持。malloc/free是库函数，需要c的头文件支持。

（2）参数：使用new操作符申请内存分配时无须制定内存块的大小，编译器会根据类型信息自行计算。而mallco则需要显式地指出所需内存的尺寸。

（3）返回类型：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，故new是符合类型安全性的操作符。而malloc内存成功分配返回的是void *，需要通过类型转换将其转换为我们需要的类型。

（4）分配失败时：new内存分配失败时抛出bad_alloc异常；malloc分配内存失败时返回 NULL。

（5）自定义类型：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

（6）重载：C++允许重载 new/delete 操作符。而malloc为库函数不允许重载。

（7）内存区域：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。其中自由存储区为：C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。



### 3. struct 和 class 的区别？

（1）首先说一下C中的结构体和C++中的结构体的异同：

 ![image-20220225095636404](.asserts/image-20220225095636404.png)

（2）C++中 struct 与 class 的区别：

* 内部成员变量及成员函数的默认访问属性：struct 默认防控属性是 public 的，而 class 默认的访问属性是private的

* 继承关系中默认访问属性的区别：在继承关系，struct 默认是 public 的，而 class 是 private

* class这个关键字还可用于定义模板参数，就等同于 typename；而strcut不用与定义模板参数



### 4. 虚函数

* 只有虚函数才能正确重写，否则override时调的还是父类的方法；

* 通过虚函数表和动态联编实现重写，会有性能损耗，但可以忽略；
* C++11提供关键字override，只用于做个标记，防止误写重写方法；

