### 1. 指针和引用的区别

（1）指针有自己的一块空间，而引用只是一个别名；

（2）使用 sizeof 看一个指针的大小为4字节（32位，如果要是64位的话指针为8字节），而引用则是被引用对象的大小。

（3）指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用。

（4）作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象。

（5）指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变。

（6）指针可以是多级，而引用没有分级

（7）如果返回动态分配内存的对象或者内存，必须使用指针，引用可能引起内存泄漏。



### 2. new 和 delete 是如何实现的，与 malloc 和 free有什么异同？

**new操作针对数据类型的处理，分为两种情况：**

（1） 简单数据类型（包括基本数据类型和不需要构造函数的类型）

* 简单类型直接调用 operator new 分配内存；

* 可以通过new_handler 来处理 new 失败的情况；

* new 分配失败的时候不像 malloc 那样返回 NULL，它直接抛出异常（bad_alloc）。要判断是否分配成功应该用异常捕获的机制；



（2）复杂数据类型（需要由构造函数初始化对象）

* new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数



**delete也分为两种情况：**

（1） 简单数据类型（包括基本数据类型和不需要析构函数的类型）

*  delete简单数据类型默认只是调用free函数。



（2）复杂数据类型（需要由析构函数销毁对象）

* delete复杂数据类型先调用析构函数再调用operator delete。



***与malloc 和 free 的区别：***

（1）属性上：new / delete 是c++关键字，需要编译器支持。malloc/free是库函数，需要c的头文件支持。

（2）参数：使用new操作符申请内存分配时无须制定内存块的大小，编译器会根据类型信息自行计算。而mallco则需要显式地指出所需内存的尺寸。

（3）返回类型：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，故new是符合类型安全性的操作符。而malloc内存成功分配返回的是void *，需要通过类型转换将其转换为我们需要的类型。

（4）分配失败时：new内存分配失败时抛出bad_alloc异常；malloc分配内存失败时返回 NULL。

（5）自定义类型：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

（6）重载：C++允许重载 new/delete 操作符。而malloc为库函数不允许重载。

（7）内存区域：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。其中自由存储区为：C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。



### 3. struct 和 class 的区别？

（1）首先说一下C中的结构体和C++中的结构体的异同：

 ![image-20220225095636404](.asserts/image-20220225095636404.png)

（2）C++中 struct 与 class 的区别：

* 内部成员变量及成员函数的默认访问属性：struct 默认防控属性是 public 的，而 class 默认的访问属性是private的

* 继承关系中默认访问属性的区别：在继承关系，struct 默认是 public 的，而 class 是 private

* class这个关键字还可用于定义模板参数，就等同于 typename；而strcut不用与定义模板参数



### 4. 虚函数

* 只有虚函数才能正确重写，否则override时调的还是父类的方法；

* 通过虚函数表和动态联编实现重写，会有性能损耗，但可以忽略；
* C++11提供关键字override，只用于做个标记，防止误写重写方法；



### 5. 左值引用和右值引用

#### 5.1 **左值和右值**

在C++11中**可以取地址的、有名字的就是左值**，反之，**不能取地址的、没有名字的就是右值**（将亡值或纯右值）。

举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。

**左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；**

右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。

**一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。**



#### 5.2 **左值引用**

**左值引用就是我们平常使用的“引用”。**引用是为对象起的别名，必须被初始化，与变量绑定到一起，且将一直绑定在一起。

我们通过 & 来获得左值引用，  
*type &引用名 = 左值表达式；* 
可以把引用绑定到一个左值上，而不能绑定到要求转换的表达式、字面常量或是返回右值的表达式。举个例子：

```c++
int i = 42;
int &r = i;    // 正确，左值引用
int &r1 = i * 42;   // 错误， i*42是一个右值
const int &r2 = i * 42; // 正确，可以将一个const的引用绑定到一个右值上
```



#### 5.3 **右值引用**

右值引用是C++11中引入的新特性 , 它实现了**转移语义和精确传递**。

它的主要目的有两个方面：

1. **消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。**
2. **能够更简洁明确地定义泛型函数。**

右值引用就是必须绑定到右值的引用，他有着与左值引用完全相反的绑定特性，我们通过 && 来获得右值引用。

右值引用的基本语法*type &&引用名 = 右值表达式；*

右值有一个重要的性质——只能绑定到一个将要销毁的对象上。举个例子：

```c++
int &&rr = i;  //错误，i是一个变量，变量都是左值
int &&rr1 = i *42;  //正确，i*42是一个右值
```



#### 5.4 右值引用和左值引用的区别

1. 左值可以寻址，而右值不可以。
2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。
3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。

参考链接：  *https://blog.csdn.net/qq_41181857/article/details/107581632*













